package net.haesleinhuepf.clijx.jython;
import org.fife.ui.autocomplete.BasicCompletion;
import net.haesleinhuepf.clijx.jython.ScriptingAutoCompleteProvider;
import java.util.ArrayList;// this is generated code. See src/test/java/net/haesleinhuepf/clijx/codegenerator for details
class CLIJxAutoComplete {
   
   public static ArrayList<BasicCompletion> getCompletions(final ScriptingAutoCompleteProvider provider) {
       ArrayList<BasicCompletion> list = new ArrayList<BasicCompletion>();
       String headline;
       String description;
       headline = "clijx.absoluteInplace(ClearCLBuffer arg1)";
       description = "<b>absoluteInplace</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.absolute(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>absolute</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImageAndScalar(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>addImageAndScalar</b><br><br>Adds a scalar value s to all pixels x of a given image X.<br><br><pre>f(x, s) = x + s</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImagesWeighted(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, Float arg4, Float arg5)";
       description = "<b>addImagesWeighted</b><br><br>Calculates the sum of pairs of pixels x and y from images X and Y weighted with factors a and b.<br><br><pre>f(x, y, a, b) = x * a + y * b</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImages(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>addImages</b><br><br>Calculates the sum of pairs of pixels x and y of two images X and Y.<br><br><pre>f(x, y) = x + y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform2D(ClearCLBuffer arg1, ClearCLImageInterface arg2, String arg3)";
       description = "<b>affineTransform2D</b><br><br>Applies an affine transform to a 2D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLImageInterface arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform3D(ClearCLBuffer arg1, ClearCLImageInterface arg2, String arg3)";
       description = "<b>affineTransform3D</b><br><br>Applies an affine transform to a 3D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLImageInterface arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorfield2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLImageInterface arg4)";
       description = "<b>applyVectorfield2D</b><br><br>Deforms an image according to distances provided in the given vector images. It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLImageInterface arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorfield3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLImageInterface arg4, ClearCLImageInterface arg5)";
       description = "<b>applyVectorfield3D</b><br><br>Deforms an image stack according to distances provided in the given vector image stacks. It is recommended to use 32-bit image stacks for input, output and vector image stacks. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLImageInterface arg4, ClearCLImageInterface arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorfield(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLImageInterface arg4)";
       description = "<b>applyVectorfield</b><br><br>Deforms an image according to distances provided in the given vector images. It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLImageInterface arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyWekaModel(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3)";
       description = "<b>applyWekaModel</b><br><br>Applies a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and applies a pre-trained a Weka model. Take care that the feature stack has been generated in the sameway as for training the model!<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.argMaximumZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>argMaximumZProjection</b><br><br>Determines the maximum projection of an image stack along Z.<br>Furthermore, another 2D image is generated with pixels containing the z-index where the maximum was found (zero based).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThresholdInplace(ClearCLBuffer arg1, String arg2)";
       description = "<b>automaticThresholdInplace</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThreshold(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3)";
       description = "<b>automaticThreshold</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageAngleBetweenAdjacentTriangles(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination)";
       description = "<b>averageAngleBetweenAdjacentTriangles</b><br><br>Takes a pointlist and a touch matrix to determine the average angle of adjacent triangles in a surface mesh. For every point, the average angle of adjacent triangles is saved.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>averageDistanceOfClosestPoints</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfNClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>averageDistanceOfNClosestPoints</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix.<br>This corresponds to the n row indices with minimum values for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination)";
       description = "<b>averageDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the average distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryAnd(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>binaryAnd</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary AND operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryEdgeDetection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>binaryEdgeDetection</b><br><br>Determines pixels/voxels which are on the surface of a binary objects and sets only them to 1 in the destination image. All other pixels are set to 0.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryIntersection(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryIntersection</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary intersection operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryNot(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>binaryNot</b><br><br>Computes a binary image (containing pixel values 0 and 1) from an image X by negating its pixel values<br>x using the binary NOT operator !<br>All pixel values except 0 in the input image are interpreted as 1.<br><br><pre>f(x) = !x</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryOr(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>binaryOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary OR operator |.<br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binarySubtract(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>binarySubtract</b><br><br>Subtracts one binary image from another.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryUnion(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryUnion</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary union operator |.<br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryXOr(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>binaryXOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary operators AND &, OR | and NOT ! implementing the XOR operator.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = (x & !y) | (!x & y)</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>blur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5)";
       description = "<b>blur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blurSliceBySlice(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>blurSliceBySlice</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The Gaussian blur is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>blur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bottomHatBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>bottomHatBox</b><br><br>Apply a bottom-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bottomHatSphere(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>bottomHatSphere</b><br><br>Applies a bottom-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.boundingBox(ClearCLBuffer source)";
       description = "<b>boundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. The positions will be stored in a new row of ImageJs<br>Results table in the column 'BoundingBoxX', 'BoundingBoxY', 'BoundingBoxZ', 'BoundingBoxWidth', 'BoundingBoxHeight' 'BoundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centerOfMass(ClearCLBuffer source)";
       description = "<b>centerOfMass</b><br><br>Determines the center of mass of an image or image stack and writes the result in the results table<br>in the columns MassX, MassY and MassZ.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centroidsOfLabels(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>centroidsOfLabels</b><br><br>Determines the centroids of all labels in a label image or image stack and writes the resulting  coordinates in a pointlist image. Depending on the dimensionality d of the labelmap and the number  of labels n, the pointlist image will have n*d pixels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closeIndexGapsInLabelMap(ClearCLBuffer binary_input, ClearCLBuffer labeling_destination)";
       description = "<b>closeIndexGapsInLabelMap</b><br><br>Analyses a label map and if there are gaps in the indexing (e.g. label 5 is not present) all <br>subsequent labels will be relabelled. Thus, afterwards number of labels and maximum label index are equal.<br><br><br>Parameters:<br>ClearCLBuffer binary_input, ClearCLBuffer labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closingBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>closingBox</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequenntly.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closingDiamond(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>closingDiamond</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequenntly.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabelingInplace(ClearCLBuffer binary_source_labeling_destination)";
       description = "<b>connectedComponentsLabelingInplace</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLBuffer binary_source_labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabeling(ClearCLBuffer binary_input, ClearCLBuffer labeling_destination)";
       description = "<b>connectedComponentsLabeling</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLBuffer binary_input, ClearCLBuffer labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copySlice(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3)";
       description = "<b>copySlice</b><br><br>This method has two purposes: <br>It copies a 2D image to a given slice z position in a 3D image stack or <br>It copies a given slice at position z in an image stack to a 2D image.<br><br>The first case is only available via ImageJ macro. If you are using it, it is recommended that the <br>target 3D image already pre-exists in GPU memory before calling this method. Otherwise, CLIJ create <br>the image stack with z planes.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copy(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>copy</b><br><br>Copies an image.<br><br><pre>f(x) = x</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels2DSphere(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixels2DSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel.Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsLocallySliceBySlice(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsLocallySliceBySlice</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsLocally(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsLocally</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsSliceBySliceSphere(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsSliceBySliceSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel slice by slice in a stack and puts the resulting number in the destination image stack.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels(ClearCLBuffer source)";
       description = "<b>countNonZeroPixels</b><br><br>Determines the number of all pixels in a given image which are not equal to 0. It will be stored in a new row of ImageJs<br>Results table in the column 'CountNonZero'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroVoxels3DSphere(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>countNonZeroVoxels3DSphere</b><br><br>Counts non-zero voxels in a sphere around every voxel.Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroVoxelsLocally(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>countNonZeroVoxelsLocally</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countTouchingNeighbors(ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination)";
       description = "<b>countTouchingNeighbors</b><br><br>Takes a touching-neighbors-matrix as input and delivers a vector with number of touching neighbors per label as a vector.<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crop2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>crop2D</b><br><br>Crops a given rectangle out of a given image.<br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crop3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>crop3D</b><br><br>Crops a given sub-stack out of a given image stack.<br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crop(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>crop</b><br><br>Crops a given rectangle out of a given image.<br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crossCorrelation(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, ClearCLBuffer arg5, int arg6, int arg7, int arg8)";
       description = "<b>crossCorrelation</b><br><br>Performs cross correlation analysis between two images. The second image is shifted by deltaPos in the given dimension. The cross correlation coefficient is calculated for each pixel in a range around the given pixel with given radius in the given dimension. Together with the original images it is recommended to hand over mean filtered images using the same radius.  <br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, ClearCLBuffer arg5, int arg6, int arg7, int arg8";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.deformableRegistration2D(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, int arg4, int arg5)";
       description = "<b>deformableRegistration2D</b><br><br>Applies particle image velocimetry to two images and registers them afterwards by warping input image 2 with a smoothed vector field.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, int arg4, int arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectLabelEdges(ClearCLBuffer label_map, ClearCLBuffer edge_image_destination)";
       description = "<b>detectLabelEdges</b><br><br>Takes a labelmap and returns an image where all pixels on label edges are set to 1 and all other pixels to 0.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer edge_image_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3)";
       description = "<b>detectMaximaBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. Pixels in the resulting image are set to 1 if<br>there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaSliceBySliceBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>detectMaximaSliceBySliceBox</b><br><br>Detects local maxima in a given square neighborhood of an input image stack. The input image stack is <br>processed slice by slice. Pixels in the resulting image are set to 1 if there is no other pixel in a <br>given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3)";
       description = "<b>detectMinimaBox</b><br><br>Detects local minima in a given square/cubic neighborhood. Pixels in the resulting image are set to 1 if<br>there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaSliceBySliceBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>detectMinimaSliceBySliceBox</b><br><br>Detects local minima in a given square neighborhood of an input image stack. The input image stack is <br>processed slice by slice. Pixels in the resulting image are set to 1 if there is no other pixel in a <br>given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian2D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6)";
       description = "<b>differenceOfGaussian2D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian3D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8)";
       description = "<b>differenceOfGaussian3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussianInplace3D(ClearCLBuffer arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7)";
       description = "<b>differenceOfGaussianInplace3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6)";
       description = "<b>differenceOfGaussian</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBoxSliceBySlice(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>dilateBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>dilateBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphereSliceBySlice(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>dilateSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>dilateSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.distanceMap(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>distanceMap</b><br><br>Generates a distance map from a binary image. Pixels with non-zero value in the binary image are set to a number representing the distance to the closest zero-value pixel.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.distanceMatrixToMesh(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, Float arg4)";
       description = "<b>distanceMatrixToMesh</b><br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a distance matrix of size n*n to draw lines from all points to points if the corresponding pixel in the distance matrix is smaller than a given distance threshold.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.divideImages(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>divideImages</b><br><br>Divides two images X and Y by each other pixel wise.<br><br><pre>f(x, y) = x / y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>downsample2D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5)";
       description = "<b>downsample3D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsampleSliceBySliceHalfMedian(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>downsampleSliceBySliceHalfMedian</b><br><br>Scales an image using scaling factors 0.5 for X and Y dimensions. The Z dimension stays untouched. Thus, each slice is processed separately.<br>The median method is applied. Thus, each pixel value in the destination image equals to the median of<br>four corresponding pixels in the source image.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>downsample</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawBox(ClearCLImageInterface arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8)";
       description = "<b>drawBox</b><br><br>Draws a box at a given start point with given size. All pixels other than in the box are untouched. Consider using clij.op.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawLine(ClearCLImageInterface arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8, Float arg9)";
       description = "<b>drawLine</b><br><br>Draws a line between two points with a given thickness. All pixels other than on the line are untouched. Consider using clij.op.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8, Float arg9";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawSphere(ClearCLImageInterface arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8)";
       description = "<b>drawSphere</b><br><br>Draws a sphere around a given point with given radii in x, y and z (if 3D). All pixels other than in the sphere are untouched. Consider using clij.op.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawTwoValueLine(ClearCLBuffer arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8, Float arg9, Float arg10)";
       description = "<b>drawTwoValueLine</b><br><br>Draws a line between two points with a given thickness. Pixels close to point 1 are set to value1. Pixels closer to point 2 are set to value2 All pixels other than on the line are untouched. Consider using clij.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLBuffer arg1, Float arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8, Float arg9, Float arg10";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equalConstant(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>equalConstant</b><br><br>Determines if an image A and a constant b are equal.<br><br>f(a, b) = 1 if a == b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equal(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>equal</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a == b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equalizeMeanIntensitiesOfSlices(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>equalizeMeanIntensitiesOfSlices</b><br><br>Determines correction factors for each z-slice so that the average intensity in all slices can be made the same and multiplies these factors with the slices.<br>This functionality is similar to the 'Simple Ratio Bleaching Correction' in Fiji.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBoxSliceBySlice(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>erodeBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>erodeBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphereSliceBySlice(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>erodeSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>erodeSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsOnEdges(ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination)";
       description = "<b>excludeLabelsOnEdges</b><br><br>Removes all labels from a label map which touch the edges of the image (in X, Y and Z if the image is 3D). Remaining label elements are renumbered afterwards.<br><br>Parameters:<br>ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.exponential(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>exponential</b><br><br>Computes base exponential of all pixels values.<br><br>f(x) = exp(x)<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.extrema(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination)";
       description = "<b>extrema</b><br><br>Returns an image with pixel values most distant from 0: f(x, y) = x if abs(x) > abs(y), y else.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.fillHistogram(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>fillHistogram</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Boolean arg3, Boolean arg4)";
       description = "<b>flip2D</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Boolean arg3, Boolean arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Boolean arg3, Boolean arg4, Boolean arg5)";
       description = "<b>flip3D</b><br><br>Flips an image in X, Y and/or Z direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Boolean arg3, Boolean arg4, Boolean arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Boolean arg3, Boolean arg4)";
       description = "<b>flip</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Boolean arg3, Boolean arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussJordan(ClearCLBuffer A_matrix, ClearCLBuffer B_result_vector, ClearCLBuffer solution_destination)";
       description = "<b>gaussJordan</b><br><br>Gauss Jordan elimination algorithm for solving linear equation systems. Ent the equation coefficients as an n*n sized image A and an n*1 sized image B:<br><pre>a(1,1)*x + a(2,1)*y + a(3,1)+z = b(1)<br>a(2,1)*x + a(2,2)*y + a(3,2)+z = b(2)<br>a(3,1)*x + a(3,2)*y + a(3,3)+z = b(3)<br></pre><br>The results will then be given in an n*1 image with values [x, y, z].<br><br>Adapted from: <br>https://github.com/qbunia/rodinia/blob/master/opencl/gaussian/gaussianElim_kernels.cl<br>L.G. Szafaryn, K. Skadron and J. Saucerman. &quot;Experiences Accelerating MATLAB Systems<br>//Biology Applications.&quot; in Workshop on Biomedicine in Computing (BiC) at the International<br>//Symposium on Computer Architecture (ISCA), June 2009.<br><br>Parameters:<br>ClearCLBuffer A_matrix, ClearCLBuffer B_result_vector, ClearCLBuffer solution_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>gaussianBlur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5)";
       description = "<b>gaussianBlur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>gaussianBlur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateDistanceMatrix(ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination)";
       description = "<b>generateDistanceMatrix</b><br><br>Takes two images containing coordinates and builds up a matrix containing distance between the points. Convention: image width represents number of points, height represents dimensionality (2D, 3D, ... 10D). The result image has width the first input image and height equals to the width of the second input image.<br><br>Parameters:<br>ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateTouchMatrix(ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination)";
       description = "<b>generateTouchMatrix</b><br><br>Takes a labelmap with n labels and generates a (n+1)*(n+1) matrix where all pixels are set to 0 exept those where labels are touching.Only half of the matrix is filled (with x < y). For example, if labels 3 and 4 are touching then the pixel (3,4) in the matrix will be set to 1.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getSize(ClearCLBuffer source)";
       description = "<b>getSize</b><br><br>Reads out the size of an image [stack] and writes it to the results table in the columns 'Width', 'Height' and 'Depth'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientX(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientX</b><br><br>Computes the gradient of gray values along X. Assuming a, b and c are three adjacent<br> pixels in X direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientY(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientY</b><br><br>Computes the gradient of gray values along Y. Assuming a, b and c are three adjacent<br> pixels in Y direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientZ(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientZ</b><br><br>Computes the gradient of gray values along Z. Assuming a, b and c are three adjacent<br> pixels in Z direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterConstant(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>greaterConstant</b><br><br>Determines if two images A and B greater pixel wise.<br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterOrEqualConstant(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>greaterOrEqualConstant</b><br><br>Determines if two images A and B greater or equal pixel wise.<br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterOrEqual(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>greaterOrEqual</b><br><br>Determines if two images A and B greater or equal pixel wise.<br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greater(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>greater</b><br><br>Determines if two images A and B greater pixel wise.<br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.histogram(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Float arg4, Float arg5, Boolean arg6)";
       description = "<b>histogram</b><br><br>Determines the histogram of a given image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Float arg4, Float arg5, Boolean arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.image2DToResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>image2DToResultsTable</b><br><br>Converts an image into a table.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.invert(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>invert</b><br><br>Computes the negative value of all pixels in a given image. It is recommended to convert images to <br>32-bit float before applying this operation.<br><br><pre>f(x) = - x</pre><br><br>For binary images, use binaryNot.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.jaccardIndex(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>jaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index.<br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelSpots(ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination)";
       description = "<b>labelSpots</b><br><br>Transforms a spots image as resulting from maximum/minimum detection in an image of the same size where every spot has a number 1, 2, ... n.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelToMask(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>labelToMask</b><br><br>Masks a single label in a label map: Sets all pixels in the target image to 1, where the given label index was present in the label map. Other pixels are set to 0.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelledSpotsToPointList(ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>labelledSpotsToPointList</b><br><br>Transforms a labelmap of spots (single pixels with values 1, 2, ..., n for n spots) as resulting from connected components analysis in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.laplaceBox(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceBox</b><br><br>Applies the Laplace operator (Box neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.laplaceSphere(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceSphere</b><br><br>Applies the Laplace operator (Diamond neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localExtremaBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>localExtremaBox</b><br><br>Applies a local minimum and maximum filter. Afterwards, the value is returned which is more far from zero.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localID(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localID</b><br><br>local id<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localPositiveMinimum(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>localPositiveMinimum</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localThreshold(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>localThreshold</b><br><br>Computes a binary image with pixel values 0 and 1 depending on if a pixel value x in image X <br>was above of equal to the pixel value m in mask image M.<br><br><pre>f(x) = (1 if (x >=  m)); (0 otherwise)</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.logarithm(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>logarithm</b><br><br>Computes base e logarithm of all pixels values.<br><br>f(x) = log(x)<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskLabel(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, Float arg4)";
       description = "<b>maskLabel</b><br><br>Computes a masked image by applying a label mask to an image. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the label_map image has the right index value i.<br><br>f(x,m,i) = (x if (m == i); (0 otherwise))<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskStackWithPlane(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>maskStackWithPlane</b><br><br>Computes a masked image by applying a 2D mask to an image stack. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same spatial position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mask(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>mask</b><br><br>Computes a masked image by applying a mask to an image. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.matrixEqual(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>matrixEqual</b><br><br>Checks if all elements of a matrix are different by less than or equal to a given tolerance.<br>The result will be put in the results table as 1 if yes and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4)";
       description = "<b>maximum2DBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>maximum2DSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5)";
       description = "<b>maximum3DBox</b><br><br>Computes the local maximum of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSliceBySliceSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>maximum3DSliceBySliceSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>maximum3DSphere</b><br><br>Computes the local maximum of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>maximumBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>maximumDiamond</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImageAndScalar(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>maximumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = max(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImages(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>maximumImages</b><br><br>Computes the maximum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = max(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOctagon(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>maximumOctagon</b><br><br>Applies a maximum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>maximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Max'.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>maximumOfMaskedPixels</b><br><br>Determines the maximum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumXProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>maximumXProjection</b><br><br>Determines the maximum projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumYProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>maximumYProjection</b><br><br>Determines the maximum projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjectionBounded(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>maximumZProjectionBounded</b><br><br>Determines the maximum projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>maximumZProjection</b><br><br>Determines the maximum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4)";
       description = "<b>mean2DBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>mean2DSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5)";
       description = "<b>mean3DBox</b><br><br>Computes the local mean average of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>mean3DSphere</b><br><br>Computes the local mean average of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5)";
       description = "<b>meanBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanClosestSpotDistances(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>meanClosestSpotDistances</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>meanOfAllPixels</b><br><br>Determines the mean average of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Mean'.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>meanOfMaskedPixels</b><br><br>Determines the mean intensity in an image, but only in pixels which have non-zero values in another binary mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfPixelsAboveThreshold(ClearCLBuffer arg1, Float arg2)";
       description = "<b>meanOfPixelsAboveThreshold</b><br><br>Determines the mean intensity in an image, but only in pixels which are above a given threshold.<br><br>Parameters:<br>ClearCLBuffer arg1, Float arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSliceBySliceSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>meanSliceBySliceSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSquaredError(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>meanSquaredError</b><br><br>Determines the mean squared error (MSE) between two images. The MSE will be stored in a new row of ImageJs<br>Results table in the column 'MSE'.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>meanZProjection</b><br><br>Determines the mean average projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>median2DBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. The rectangle is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>median2DSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>median3DBox</b><br><br>Computes the local median of a pixels cuboid neighborhood. The cuboid size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the cuboid must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSliceBySliceBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>median3DSliceBySliceBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. This is done slice-by-slice in a 3D <br>image stack. The rectangle is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSliceBySliceSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>median3DSliceBySliceSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. This is done slice-by-slice in a 3D <br>image stack. The ellipses size is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>median3DSphere</b><br><br>Computes the local median of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the sphere must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.medianZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>medianZProjection</b><br><br>Determines the median projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4)";
       description = "<b>minimum2DBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>minimum2DSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5)";
       description = "<b>minimum3DBox</b><br><br>Computes the local minimum of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4, int arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSliceBySliceSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>minimum3DSliceBySliceSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSphere(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>minimum3DSphere</b><br><br>Computes the local minimum of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>minimumBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>minimumDiamond</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination)";
       description = "<b>minimumDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the shortest distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImageAndScalar(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>minimumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = min(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImages(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>minimumImages</b><br><br>Computes the minimum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = min(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOctagon(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>minimumOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>minimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Min'.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>minimumOfMaskedPixels</b><br><br>Determines the minimum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjectionBounded(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>minimumZProjectionBounded</b><br><br>Determines the minimum projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjectionThresholdedBounded(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Integer arg4, Integer arg5)";
       description = "<b>minimumZProjectionThresholdedBounded</b><br><br>Determines the minimum projection of all pixels in an image above a given threshold along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>minimumZProjection</b><br><br>Determines the minimum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndCoordinate(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3)";
       description = "<b>multiplyImageAndCoordinate</b><br><br>Multiplies all pixel intensities with the x, y or z coordinate, depending on specified dimension.</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndScalar(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>multiplyImageAndScalar</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s.<br><br><pre>f(x, s) = x * s</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImages(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>multiplyImages</b><br><br>Multiplies all pairs of pixel values x and y from two image X and Y.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyMatrix(ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination)";
       description = "<b>multiplyMatrix</b><br><br>Multiplies two matrices with each other.<br><br>Parameters:<br>ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyStackWithPlane(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>multiplyStackWithPlane</b><br><br>Multiplies all pairs of pixel values x and y from an image stack X and a 2D image Y. x and y are at <br>the same spatial position within a plane.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>nClosestPoints</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix.<br>This corresponds to the n row indices with minimum values for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMaximumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4)";
       description = "<b>nonzeroMaximumBox</b><br><br>Apply a maximum filter (box shape) to the input image. The radius is fixed to 1 and pixels with value 0 are ignored.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMaximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4)";
       description = "<b>nonzeroMaximumDiamond</b><br><br>Apply a maximum filter (diamond shape) to the input image. The radius is fixed to 1 and pixels with value 0 are ignored.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMinimumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4)";
       description = "<b>nonzeroMinimumBox</b><br><br>Apply a minimum filter (box shape) to the input image. The radius is fixed to 1 and pixels with value 0 are ignored.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.nonzeroMinimumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4)";
       description = "<b>nonzeroMinimumDiamond</b><br><br>Apply a minimum filter (diamond shape) to the input image. The radius is fixed to 1 and pixels with value 0 are ignored.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, ClearCLKernel arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.notEqualConstant(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>notEqualConstant</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.notEqual(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLBuffer arg3)";
       description = "<b>notEqual</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLBuffer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.onlyzeroOverwriteMaximumBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>onlyzeroOverwriteMaximumBox</b><br><br>TODO<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.onlyzeroOverwriteMaximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>onlyzeroOverwriteMaximumDiamond</b><br><br>TODO<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.openingBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>openingBox</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.openingDiamond(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>openingDiamond</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.organiseWindows(int arg1, int arg2, int arg3, int arg4, int arg5, int arg6)";
       description = "<b>organiseWindows</b><br><br>Organises windows on screen.<br><br>Parameters:<br>int arg1, int arg2, int arg3, int arg4, int arg5, int arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetry2D(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, Integer arg5)";
       description = "<b>particleImageVelocimetry2D</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetryTimelapse(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, int arg5, int arg6, int arg7, boolean arg8)";
       description = "<b>particleImageVelocimetryTimelapse</b><br><br>Run particle image velocimetry on a 2D+t timelapse.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, int arg5, int arg6, int arg7, boolean arg8";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetry(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, ClearCLBuffer arg5, Integer arg6, Integer arg7, Integer arg8, boolean arg9)";
       description = "<b>particleImageVelocimetry</b><br><br>For every pixel in source image 1, determine the pixel with the most similar intensity in <br> the local neighborhood with a given radius in source image 2. Write the distance in <br>X and Y in the two corresponding destination images.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, ClearCLBuffer arg4, ClearCLBuffer arg5, Integer arg6, Integer arg7, Integer arg8, boolean arg9";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>paste2D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>paste3D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>paste</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pointIndexListToMesh(ClearCLBuffer pointlist, ClearCLBuffer indexList, ClearCLBuffer Mesh)";
       description = "<b>pointIndexListToMesh</b><br><br>Meshes all points in a given point list which are indiced in a corresponding index list. TODO: Explain better<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer indexList, ClearCLBuffer Mesh";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.powerImages(ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination)";
       description = "<b>powerImages</b><br><br>Calculates x to the power of y pixel wise of two images X and Y.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.power(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3)";
       description = "<b>power</b><br><br>Computes all pixels value x to the power of a given exponent a.<br><br><pre>f(x, a) = x ^ a</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.preloadFromDisc(ClearCLBuffer arg1, String arg2, String arg3, String arg4)";
       description = "<b>preloadFromDisc</b><br><br>This plugin takes two image filenames and loads them into RAM. The first image is returned immediately, the second image is loaded in the background and  will be returned when the plugin is called again.<br><br> It is assumed that all images have the same size. If this is not the case, call release(image) before  getting the second image.<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2, String arg3, String arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.presign(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>presign</b><br><br>Determines the extrema of pixel values: f(x) = x / abs(x).<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.projectMeanZBounded(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>projectMeanZBounded</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullAsROI(ClearCLBuffer binary_input)";
       description = "<b>pullAsROI</b><br><br>Pulls a binary image from the GPU memory and puts it on the currently active ImageJ window.<br><br>Parameters:<br>ClearCLBuffer binary_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullLabelsToROIManager(ClearCLBuffer arg1, RoiManager arg2)";
       description = "<b>pullLabelsToROIManager</b><br><br>Pulls all labels in a label map as ROIs to the ROI manager.<br><br>Parameters:<br>ClearCLBuffer arg1, RoiManager arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.radialProjection(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>radialProjection</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.readImageFromDisc(String arg1)";
       description = "<b>readImageFromDisc</b><br><br>Read an image from disc.<br><br>Parameters:<br>String arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.readRawImageFromDisc(ClearCLBuffer arg1, String arg2)";
       description = "<b>readRawImageFromDisc</b><br><br>Reads a raw file from disc and pushes it immediately to the GPU.<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replaceIntensities(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>replaceIntensities</b><br><br>Replaces integer intensities specified in a vector image. The vector image must be 3D with size (m, 1, 1) where m corresponds to the maximum intensity in the original image. Assuming the vector image contains values (0, 1, 0, 2) means: <br> * All pixels with value 0 (first entry in the vector image) get value 0<br> * All pixels with value 1 get value 1<br> * All pixels with value 2 get value 0<br> * All pixels with value 3 get value 2<br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replaceIntensity(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>replaceIntensity</b><br><br>Replaces a specific intensity in an image with a given new value.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resample(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5, boolean arg6)";
       description = "<b>resample</b><br><br>Resamples an image with given size factors using an affine transform.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5, boolean arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceBottom(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>resliceBottom</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceLeft(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>resliceLeft</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRadial(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8)";
       description = "<b>resliceRadial</b><br><br>Computes a radial projection of an image stack. Starting point for the line is the center in any <br>X/Y-plane of a given input image stack. This operation is similar to ImageJs 'Radial Reslice' method but offers less flexibility.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Float arg6, Float arg7, Float arg8";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRight(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>resliceRight</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceTop(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>resliceTop</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate2D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Boolean arg4)";
       description = "<b>rotate2D</b><br><br>Rotates an image in plane. All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Boolean arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate3D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Boolean arg6)";
       description = "<b>rotate3D</b><br><br>Rotates an image stack in 3D. All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image stack.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5, Boolean arg6";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateClockwise(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>rotateClockwise</b><br><br>Rotates a given input image by 90 degrees clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateCounterClockwise(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>rotateCounterClockwise</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateLeft(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>rotateLeft</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateRight(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>rotateRight</b><br><br>Rotates a given input image by 90 degrees clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotatedRight(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>rotatedRight</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.saveAsTIF(ClearCLBuffer arg1, String arg2)";
       description = "<b>saveAsTIF</b><br><br>Pulls an image from the GPU memory and saves it as TIF to disc.<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.scale2D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>scale2D</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.scale3D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5)";
       description = "<b>scale3D</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.scale(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>scale</b><br><br>DEPRECATED: CLIJ scale() is <b>deprecated</b>. Use scale2D or scale3D instead!<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setColumn(ClearCLImageInterface arg1, Integer arg2, Float arg3)";
       description = "<b>setColumn</b><br><br>Sets all pixel values x of a given column in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, Integer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setNonZeroPixelsToPixelIndex(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>setNonZeroPixelsToPixelIndex</b><br><br>Sets all pixels in an image which are not zero to the index of the pixel. This can be used for Connected Components Analysis.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampX(ClearCLImageInterface arg1)";
       description = "<b>setRampX</b><br><br>Sets all pixel values to their X coordinate<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampY(ClearCLImageInterface arg1)";
       description = "<b>setRampY</b><br><br>Sets all pixel values to their Y coordinate<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampZ(ClearCLImageInterface arg1)";
       description = "<b>setRampZ</b><br><br>Sets all pixel values to their Z coordinate<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRow(ClearCLImageInterface arg1, Integer arg2, Float arg3)";
       description = "<b>setRow</b><br><br>Sets all pixel values x of a given row in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, Integer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXequalsY(ClearCLImageInterface arg1, Float arg2)";
       description = "<b>setWhereXequalsY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x == y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXgreaterThanY(ClearCLImageInterface arg1, Float arg2)";
       description = "<b>setWhereXgreaterThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x > y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXsmallerThanY(ClearCLImageInterface arg1, Float arg2)";
       description = "<b>setWhereXsmallerThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x < y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.set(ClearCLImageInterface arg1, Float arg2)";
       description = "<b>set</b><br><br>Sets all pixel values x of a given image X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, Float arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.shiftIntensitiesToCloseGaps(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>shiftIntensitiesToCloseGaps</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.shortestDistances(ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances)";
       description = "<b>shortestDistances</b><br><br>Determine the shortest distance from a distance matrix. This corresponds to the minimum in a matrix for each individial column.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGlasbeyOnGrey(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3)";
       description = "<b>showGlasbeyOnGrey</b><br><br>Visualises two 2D images as one RGB image. The first channel is shown in grey, the second with glasbey LUT.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGrey(ClearCLBuffer arg1, String arg2)";
       description = "<b>showGrey</b><br><br>Visualises a single 2D image.<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showRGB(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, String arg4)";
       description = "<b>showRGB</b><br><br>Visualises three 2D images as one RGB image<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3, String arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerConstant(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>smallerConstant</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerOrEqualConstant(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>smallerOrEqualConstant</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerOrEqual(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smallerOrEqual</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smaller(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smaller</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sobel(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>sobel</b><br><br>Convolve the image with the Sobel kernel.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sorensenDiceCoefficient(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>sorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent.<br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.spotsToPointList(ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>spotsToPointList</b><br><br>Transforms a spots image as resulting from maximum/minimum detection in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stackToTiles(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>stackToTiles</b><br><br>Stack to tiles.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>standardDeviationOfAllPixels</b><br><br>Determines the standard deviation of all pixels in an image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Standard_deviation'.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>standardDeviationOfMaskedPixels</b><br><br>Determines the standard deviation of all pixels in an image which have non-zero value in a corresponding mask image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Masked_standard_deviation'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>standardDeviationZProjection</b><br><br>Determines the standard deviation projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfLabelledPixels(ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3)";
       description = "<b>statisticsOfLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity  of a labelled object in a label map and corresponding pixels in the original image.Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, int arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stopWatch(String arg1)";
       description = "<b>stopWatch</b><br><br>Measures time and outputs delay to last call.<br><br>Parameters:<br>String arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>subtractBackground2D</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5)";
       description = "<b>subtractBackground3D</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>subtractBackground</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractImages(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>subtractImages</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtract(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>subtract</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>sumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumPixels(ClearCLImageInterface arg1)";
       description = "<b>sumPixels</b><br><br>Determines the sum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumYProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>sumYProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumZProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2)";
       description = "<b>sumZProjection</b><br><br>Determines the sum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.threshold(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>threshold</b><br><br>Computes a binary image with pixel values 0 and 1. All pixel values x of a given input image with <br>value larger or equal to a given threshold t will be set to 1.<br><br>f(x,t) = (1 if (x >= t); (0 otherwise))<br><br>This plugin is comparable to setting a raw threshold in ImageJ and using the 'Convert to Mask' menu.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>topHatBox</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatOctagonSliceBySlice(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>topHatOctagonSliceBySlice</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations - 2 makes the filter result very similar to minimum sphere.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatOctagon(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>topHatOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations - 2 makes the filter result very similar to minimum sphere.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatSphere(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>topHatSphere</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.touchMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination)";
       description = "<b>touchMatrixToMesh</b><br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a touch matrix of size n*n to draw lines from all points to points if the corresponding pixel in the touch matrix is 1.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaModel(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3)";
       description = "<b>trainWekaModel</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and trains a Weka model. This model will be saved to disc.<br>The given groundTruth image is supposed to be a label map where pixels with value 1 represent class 1, pixels with value 2 represent class 2 and so on. Pixels with value 0 will be ignored for training.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate2D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>translate2D</b><br><br>Translate an image stack in X and Y.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate3D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5)";
       description = "<b>translate3D</b><br><br>Translate an image stack in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4, Float arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translationRegistration(ClearCLBuffer arg1, ClearCLBuffer arg2, double[] arg3)";
       description = "<b>translationRegistration</b><br><br>Measures center of mass of thresholded objects in the two input images and translates the second image so that it better fits to the first image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, double[] arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translationTimelapseRegistration(ClearCLBuffer input, ClearCLBuffer output)";
       description = "<b>translationTimelapseRegistration</b><br><br>Applies 2D translation registration to every pair of t, t+1 slices of a 2D+t image stack.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer output";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeXY(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXY</b><br><br>Transpose X and Y axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeXZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXZ</b><br><br>Transpose X and Z axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeYZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeYZ</b><br><br>Transpose Y and Z axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfAllPixels(ClearCLBuffer source)";
       description = "<b>varianceOfAllPixels</b><br><br>Determines the variance of all pixels in an image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Variance'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>varianceOfMaskedPixels</b><br><br>Determines the variance in an image, but only in pixels which have non-zero values in another binary mask image. The result is put in the results table as new column named 'Masked_variance'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.watershed(ClearCLBuffer binary_source, ClearCLBuffer destination)";
       description = "<b>watershed</b><br><br>Apply a binary watershed to a binary image and introduces black pixels between objects.<br><br>Parameters:<br>ClearCLBuffer binary_source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeVTKLineListToDisc(ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3)";
       description = "<b>writeVTKLineListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and a corresponding touch matrix , sized (n+1)*(n+1), and exports them in VTK format.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeValuesToPositions(ClearCLBuffer positionsAndValues, ClearCLBuffer destination)";
       description = "<b>writeValuesToPositions</b><br><br>Takes an image with three/four rows (2D: height = 3; 3D: height = 4): x, y [, z] and v and target image. The value v will be written at position x/y[/z] in the target image.<br><br>Parameters:<br>ClearCLBuffer positionsAndValues, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeXYZPointListToDisc(ClearCLBuffer arg1, String arg2)";
       description = "<b>writeXYZPointListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and exports them in XYZ format.<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
        return list;
    }
}
// 286 methods generated.

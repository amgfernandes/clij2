package net.haesleinhuepf.clijx.jython;
import org.fife.ui.autocomplete.BasicCompletion;
import net.haesleinhuepf.clijx.jython.ScriptingAutoCompleteProvider;
import java.util.ArrayList;// this is generated code. See src/test/java/net/haesleinhuepf/clijx/codegenerator for details
class CLIJxAutoComplete {
   
   public static ArrayList<BasicCompletion> getCompletions(final ScriptingAutoCompleteProvider provider) {
       ArrayList<BasicCompletion> list = new ArrayList<BasicCompletion>();
       String headline;
       String description;
       headline = "clijx.absolute(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>absolute</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>addImageAndScalar</b><br><br>Adds a scalar value s to all pixels x of a given image X.<br><br><pre>f(x, s) = x + s</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImagesWeighted(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2)";
       description = "<b>addImagesWeighted</b><br><br>Calculates the sum of pairs of pixels x and y from images X and Y weighted with factors a and b.<br><br><pre>f(x, y, a, b) = x * a + y * b</pre><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.addImages(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination)";
       description = "<b>addImages</b><br><br>Calculates the sum of pairs of pixels x and y of two images X and Y.<br><br><pre>f(x, y) = x + y</pre><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform2D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform2D</b><br><br>Applies an affine transform to a 2D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.affineTransform3D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform3D</b><br><br>Applies an affine transform to a 3D image. Individual transforms must be separated by spaces.<br><br>Supported transforms:<br>* center: translate the coordinate origin to the center of the image<br>* -center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;center scale=2 rotate=45 -center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField2D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination)";
       description = "<b>applyVectorField2D</b><br><br>Deforms an image according to distances provided in the given vector images. It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField3D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination)";
       description = "<b>applyVectorField3D</b><br><br>Deforms an image stack according to distances provided in the given vector image stacks. It is recommended to use 32-bit image stacks for input, output and vector image stacks. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyVectorField(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination)";
       description = "<b>applyVectorField</b><br><br>Deforms an image according to distances provided in the given vector images. It is recommended to use 32-bit images for input, output and vector images. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.applyWekaModel(ClearCLBuffer featureStack3D, ClearCLBuffer prediction2D_destination, String loadModelFilename)";
       description = "<b>applyWekaModel</b><br><br>Applies a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and applies a pre-trained a Weka model. Take care that the feature stack has been generated in the sameway as for training the model!<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer prediction2D_destination, String loadModelFilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.argMaximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max)";
       description = "<b>argMaximumZProjection</b><br><br>Determines the maximum projection of an image stack along Z.<br>Furthermore, another 2D image is generated with pixels containing the z-index where the maximum was found (zero based).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThresholdInplace(ClearCLBuffer input_and_destination, String method)";
       description = "<b>automaticThresholdInplace</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer input_and_destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.automaticThreshold(ClearCLBuffer input, ClearCLBuffer destination, String method)";
       description = "<b>automaticThreshold</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method. Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageAngleBetweenAdjacentTriangles(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination)";
       description = "<b>averageAngleBetweenAdjacentTriangles</b><br><br>Takes a pointlist and a touch matrix to determine the average angle of adjacent triangles in a surface mesh. For every point, the average angle of adjacent triangles is saved.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfNClosestPoints(ClearCLBuffer distance_matrix, ClearCLBuffer indexlist_destination, Integer nClosestPointsTofind)";
       description = "<b>averageDistanceOfNClosestPoints</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix.<br>This corresponds to the n row indices with minimum values for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer indexlist_destination, Integer nClosestPointsTofind";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.averageDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination)";
       description = "<b>averageDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the average distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryAnd(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryAnd</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary AND operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryEdgeDetection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryEdgeDetection</b><br><br>Determines pixels/voxels which are on the surface of a binary objects and sets only them to 1 in the destination image. All other pixels are set to 0.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryIntersection(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryIntersection</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary intersection operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryNot(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryNot</b><br><br>Computes a binary image (containing pixel values 0 and 1) from an image X by negating its pixel values<br>x using the binary NOT operator !<br>All pixel values except 0 in the input image are interpreted as 1.<br><br><pre>f(x) = !x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary OR operator |.<br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binarySubtract(ClearCLImageInterface minuend, ClearCLImageInterface subtrahend, ClearCLImageInterface destination)";
       description = "<b>binarySubtract</b><br><br>Subtracts one binary image from another.<br><br>Parameters:<br>ClearCLImageInterface minuend, ClearCLImageInterface subtrahend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryUnion(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryUnion</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary union operator |.<br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.binaryXOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryXOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary operators AND &, OR | and NOT ! implementing the XOR operator.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = (x & !y) | (!x & y)</pre><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>blur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blurSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blurSliceBySlice</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The Gaussian blur is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.blur(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>blur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bottomHatBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>bottomHatBox</b><br><br>Apply a bottom-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.bottomHatSphere(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>bottomHatSphere</b><br><br>Applies a bottom-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.boundingBox(ClearCLBuffer source)";
       description = "<b>boundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. The positions will be stored in a new row of ImageJs<br>Results table in the column 'BoundingBoxX', 'BoundingBoxY', 'BoundingBoxZ', 'BoundingBoxWidth', 'BoundingBoxHeight' 'BoundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.centerOfMass(ClearCLBuffer source)";
       description = "<b>centerOfMass</b><br><br>Determines the center of mass of an image or image stack and writes the result in the results table<br>in the columns MassX, MassY and MassZ.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closeIndexGapsInLabelMap(ClearCLBuffer binary_input, ClearCLBuffer labeling_destination)";
       description = "<b>closeIndexGapsInLabelMap</b><br><br>Analyses a label map and if there are gaps in the indexing (e.g. label 5 is not present) all <br>subsequent labels will be relabelled. Thus, afterwards number of labels and maximum label index are equal.<br><br><br>Parameters:<br>ClearCLBuffer binary_input, ClearCLBuffer labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closingBox(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erosions)";
       description = "<b>closingBox</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erosions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.closingDiamond(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erotions)";
       description = "<b>closingDiamond</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erotions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabelingInplace(ClearCLBuffer binary_source_labeling_destination)";
       description = "<b>connectedComponentsLabelingInplace</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLBuffer binary_source_labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.connectedComponentsLabeling(ClearCLBuffer binary_input, ClearCLBuffer labeling_destination)";
       description = "<b>connectedComponentsLabeling</b><br><br>Performs connected components analysis to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLBuffer binary_input, ClearCLBuffer labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Integer sliceIndex)";
       description = "<b>copySlice</b><br><br>This method has two purposes: <br>It copies a 2D image to a given slice z position in a 3D image stack or <br>It copies a given slice at position z in an image stack to a 2D image.<br><br>The first case is only available via ImageJ macro. If you are using it, it is recommended that the <br>target 3D image already pre-exists in GPU memory before calling this method. Otherwise, CLIJ create <br>the image stack with z planes.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer sliceIndex";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.copy(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>copy</b><br><br>Copies an image.<br><br><pre>f(x) = x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels2DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixels2DSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel.Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixelsSliceBySliceSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixelsSliceBySliceSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel slice by slice in a stack and puts the resulting number in the destination image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroPixels(ClearCLBuffer source)";
       description = "<b>countNonZeroPixels</b><br><br>Determines the number of all pixels in a given image which are not equal to 0. It will be stored in a new row of ImageJs<br>Results table in the column 'CountNonZero'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countNonZeroVoxels3DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>countNonZeroVoxels3DSphere</b><br><br>Counts non-zero voxels in a sphere around every voxel.Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.countTouchingNeighbors(ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination)";
       description = "<b>countTouchingNeighbors</b><br><br>Takes a touching-neighbors-matrix as input and delivers a vector with number of touching neighbors per label as a vector.<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.crossCorrelation(ClearCLBuffer input1, ClearCLBuffer meanInput1, ClearCLBuffer input2, ClearCLBuffer meanInput2, ClearCLBuffer destination, Integer radius, Integer deltaPos, Integer dimension)";
       description = "<b>crossCorrelation</b><br><br>Performs cross correlation analysis between two images. The second image is shifted by deltaPos in the given dimension. The cross correlation coefficient is calculated for each pixel in a range around the given pixel with given radius in the given dimension. Together with the original images it is recommended to hand over mean filtered images using the same radius.  <br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer meanInput1, ClearCLBuffer input2, ClearCLBuffer meanInput2, ClearCLBuffer destination, Integer radius, Integer deltaPos, Integer dimension";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.deformableRegistration2D(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination, Integer maxDeltaX, Integer maxDeltaY)";
       description = "<b>deformableRegistration2D</b><br><br>Applies particle image velocimetry to two images and registers them afterwards by warping input image 2 with a smoothed vector field.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination, Integer maxDeltaX, Integer maxDeltaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectLabelEdges(ClearCLBuffer label_map, ClearCLBuffer edge_image_destination)";
       description = "<b>detectLabelEdges</b><br><br>Takes a labelmap and returns an image where all pixels on label edges are set to 1 and all other pixels to 0.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer edge_image_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMaximaBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. Pixels in the resulting image are set to 1 if<br>there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMaximaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radius)";
       description = "<b>detectMaximaSliceBySliceBox</b><br><br>Detects local maxima in a given square neighborhood of an input image stack. The input image stack is <br>processed slice by slice. Pixels in the resulting image are set to 1 if there is no other pixel in a <br>given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMinimaBox</b><br><br>Detects local minima in a given square/cubic neighborhood. Pixels in the resulting image are set to 1 if<br>there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.detectMinimaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radius)";
       description = "<b>detectMinimaSliceBySliceBox</b><br><br>Detects local minima in a given square neighborhood of an input image stack. The input image stack is <br>processed slice by slice. Pixels in the resulting image are set to 1 if there is no other pixel in a <br>given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian2D(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y)";
       description = "<b>differenceOfGaussian2D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian3D(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z)";
       description = "<b>differenceOfGaussian3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussianInplace3D(ClearCLBuffer input_and_destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z)";
       description = "<b>differenceOfGaussianInplace3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input_and_destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.differenceOfGaussian(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y)";
       description = "<b>differenceOfGaussian</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.dilateSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.distanceMap(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>distanceMap</b><br><br>Generates a distance map from a binary image. Pixels with non-zero value in the binary image are set to a number representing the distance to the closest zero-value pixel.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.distanceMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer distance_matrix, ClearCLBuffer mesh_destination, Float maximumDistance)";
       description = "<b>distanceMatrixToMesh</b><br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a distance matrix of size n*n to draw lines from all points to points if the corresponding pixel in the distance matrix is smaller than a given distance threshold.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer distance_matrix, ClearCLBuffer mesh_destination, Float maximumDistance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.divideImages(ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination)";
       description = "<b>divideImages</b><br><br>Divides two images X and Y by each other pixel wise.<br><br><pre>f(x, y) = x / y</pre><br><br>Parameters:<br>ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample2D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ)";
       description = "<b>downsample3D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsampleSliceBySliceHalfMedian(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>downsampleSliceBySliceHalfMedian</b><br><br>Scales an image using scaling factors 0.5 for X and Y dimensions. The Z dimension stays untouched. Thus, each slice is processed separately.<br>The median method is applied. Thus, each pixel value in the destination image equals to the median of<br>four corresponding pixels in the source image.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.downsample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample</b><br><br>Scales an image using given scaling factors for X and Y dimensions. The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawBox(ClearCLImageInterface destination, Float x, Float y, Float z, Float width, Float height, Float depth, Float value)";
       description = "<b>drawBox</b><br><br>Draws a box at a given start point with given size. All pixels other than in the box are untouched. Consider using clij.op.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x, Float y, Float z, Float width, Float height, Float depth, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawLine(ClearCLImageInterface destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value)";
       description = "<b>drawLine</b><br><br>Draws a line between two points with a given thickness. All pixels other than on the line are untouched. Consider using clij.op.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawSphere(ClearCLImageInterface destination, Float x, Float y, Float z, Float radius_x, Float radius_y, Float radius_z, Float value)";
       description = "<b>drawSphere</b><br><br>Draws a sphere around a given point with given radii in x, y and z (if 3D). All pixels other than in the sphere are untouched. Consider using clij.op.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x, Float y, Float z, Float radius_x, Float radius_y, Float radius_z, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.drawTwoValueLine(ClearCLBuffer destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value1, Float destination0)";
       description = "<b>drawTwoValueLine</b><br><br>Draws a line between two points with a given thickness. Pixels close to point 1 are set to value1. Pixels closer to point 2 are set to value2 All pixels other than on the line are untouched. Consider using clij.set(buffer, 0); in advance.<br><br>Parameters:<br>ClearCLBuffer destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value1, Float destination0";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equalConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>equalConstant</b><br><br>Determines if an image A and a constant b are equal.<br><br>f(a, b) = 1 if a == b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equal(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>equal</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a == b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.equalizeMeanIntensitiesOfSlices(ClearCLBuffer input, ClearCLBuffer destination, Integer referenceSlice)";
       description = "<b>equalizeMeanIntensitiesOfSlices</b><br><br>Determines correction factors for each z-slice so that the average intensity in all slices can be made the same and multiplies these factors with the slices.<br>This functionality is similar to the 'Simple Ratio Bleaching Correction' in Fiji.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer referenceSlice";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.erodeSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image.<br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsOnEdges(ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination)";
       description = "<b>excludeLabelsOnEdges</b><br><br>Removes all labels from a label map which touch the edges of the image (in X, Y and Z if the image is 3D). Remaining label elements are renumbered afterwards.<br><br>Parameters:<br>ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsOnSurface(ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ)";
       description = "<b>excludeLabelsOnSurface</b><br><br>This operation follows a ray from a given position towards a label (or opposite direction) and checks if  there is another label between the label an the image border. If yes, this label is eliminated from the label map.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.excludeLabelsSubSurface(ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ)";
       description = "<b>excludeLabelsSubSurface</b><br><br>This operation follows a ray from a given position towards a label (or opposite direction) and checks if  there is another label between the label an the image border. If yes, this label is eliminated from the label map.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.exponential(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>exponential</b><br><br>Computes base exponential of all pixels values.<br><br>f(x) = exp(x)<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.extrema(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination)";
       description = "<b>extrema</b><br><br>Returns an image with pixel values most distant from 0: f(x, y) = x if abs(x) > abs(y), y else.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip2D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY)";
       description = "<b>flip2D</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip3D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY, Boolean flipZ)";
       description = "<b>flip3D</b><br><br>Flips an image in X, Y and/or Z direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY, Boolean flipZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.flip(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY)";
       description = "<b>flip</b><br><br>Flips an image in X and/or Y direction depending on boolean flags.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flipX, Boolean flipY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussJordan(ClearCLBuffer A_matrix, ClearCLBuffer B_result_vector, ClearCLBuffer solution_destination)";
       description = "<b>gaussJordan</b><br><br>Gauss Jordan elimination algorithm for solving linear equation systems. Ent the equation coefficients as an n*n sized image A and an n*1 sized image B:<br><pre>a(1,1)*x + a(2,1)*y + a(3,1)+z = b(1)<br>a(2,1)*x + a(2,2)*y + a(3,2)+z = b(2)<br>a(3,1)*x + a(3,2)*y + a(3,3)+z = b(3)<br></pre><br>The results will then be given in an n*1 image with values [x, y, z].<br><br>Adapted from: <br>https://github.com/qbunia/rodinia/blob/master/opencl/gaussian/gaussianElim_kernels.cl<br>L.G. Szafaryn, K. Skadron and J. Saucerman. &quot;Experiences Accelerating MATLAB Systems<br>//Biology Applications.&quot; in Workshop on Biomedicine in Computing (BiC) at the International<br>//Symposium on Computer Architecture (ISCA), June 2009.<br><br>Parameters:<br>ClearCLBuffer A_matrix, ClearCLBuffer B_result_vector, ClearCLBuffer solution_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>gaussianBlur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>gaussianBlur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gaussianBlur(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>gaussianBlur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateDistanceMatrix(ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination)";
       description = "<b>generateDistanceMatrix</b><br><br>Takes two images containing coordinates and builds up a matrix containing distance between the points. Convention: image width represents number of points, height represents dimensionality (2D, 3D, ... 10D). The result image has width the first input image and height equals to the width of the second input image.<br><br>Parameters:<br>ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.generateTouchMatrix(ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination)";
       description = "<b>generateTouchMatrix</b><br><br>Takes a labelmap with n labels and generates a (n+1)*(n+1) matrix where all pixels are set to 0 exept those where labels are touching.Only half of the matrix is filled (with x < y). For example, if labels 3 and 4 are touching then the pixel (3,4) in the matrix will be set to 1.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.getSize(ClearCLBuffer source)";
       description = "<b>getSize</b><br><br>Reads out the size of an image [stack] and writes it to the results table in the columns 'Width', 'Height' and 'Depth'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientX(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientX</b><br><br>Computes the gradient of gray values along X. Assuming a, b and c are three adjacent<br> pixels in X direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientY(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientY</b><br><br>Computes the gradient of gray values along Y. Assuming a, b and c are three adjacent<br> pixels in Y direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.gradientZ(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientZ</b><br><br>Computes the gradient of gray values along Z. Assuming a, b and c are three adjacent<br> pixels in Z direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>greaterConstant</b><br><br>Determines if two images A and B greater pixel wise.<br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterOrEqualConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>greaterOrEqualConstant</b><br><br>Determines if two images A and B greater or equal pixel wise.<br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greaterOrEqual(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>greaterOrEqual</b><br><br>Determines if two images A and B greater or equal pixel wise.<br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.greater(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>greater</b><br><br>Determines if two images A and B greater pixel wise.<br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.histogram(ClearCLBuffer source, ClearCLBuffer destination, Integer numberOfBins, Float minimumGreyValue, Float maximumGreyValue, Boolean determineMinAndMax)";
       description = "<b>histogram</b><br><br>Determines the histogram of a given image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer numberOfBins, Float minimumGreyValue, Float maximumGreyValue, Boolean determineMinAndMax";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.imageToStack(ClearCLBuffer source, ClearCLBuffer destination, Integer num_slices)";
       description = "<b>imageToStack</b><br><br>Copies a single slice into a stack a given number of times.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer num_slices";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.invert(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>invert</b><br><br>Computes the negative value of all pixels in a given image. It is recommended to convert images to <br>32-bit float before applying this operation.<br><br><pre>f(x) = - x</pre><br><br>For binary images, use binaryNot.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.jaccardIndex(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>jaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index.<br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelSpots(ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination)";
       description = "<b>labelSpots</b><br><br>Transforms a spots image as resulting from maximum/minimum detection in an image of the same size where every spot has a number 1, 2, ... n.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelToMask(ClearCLBuffer label_map_source, ClearCLBuffer mask_destination, Float label_index)";
       description = "<b>labelToMask</b><br><br>Masks a single label in a label map: Sets all pixels in the target image to 1, where the given label index was present in the label map. Other pixels are set to 0.<br><br>Parameters:<br>ClearCLBuffer label_map_source, ClearCLBuffer mask_destination, Float label_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.labelledSpotsToPointList(ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>labelledSpotsToPointList</b><br><br>Transforms a labelmap of spots (single pixels with values 1, 2, ..., n for n spots) as resulting from connected components analysis in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.laplaceBox(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceBox</b><br><br>Applies the Laplace operator (Box neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.laplaceSphere(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceSphere</b><br><br>Applies the Laplace operator (Diamond neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localExtremaBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>localExtremaBox</b><br><br>Applies a local minimum and maximum filter. Afterwards, the value is returned which is more far from zero.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localID(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>localID</b><br><br>local id<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.localThreshold(ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination)";
       description = "<b>localThreshold</b><br><br>Computes a binary image with pixel values 0 and 1 depending on if a pixel value x in image X <br>was above of equal to the pixel value m in mask image M.<br><br><pre>f(x) = (1 if (x >=  m)); (0 otherwise)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.logarithm(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>logarithm</b><br><br>Computes base e logarithm of all pixels values.<br><br>f(x) = log(x)<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskLabel(ClearCLBuffer source, ClearCLBuffer label_map, ClearCLBuffer destination, Float label_index)";
       description = "<b>maskLabel</b><br><br>Computes a masked image by applying a label mask to an image. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the label_map image has the right index value i.<br><br>f(x,m,i) = (x if (m == i); (0 otherwise))<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer label_map, ClearCLBuffer destination, Float label_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maskStackWithPlane(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>maskStackWithPlane</b><br><br>Computes a masked image by applying a 2D mask to an image stack. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same spatial position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mask(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>mask</b><br><br>Computes a masked image by applying a mask to an image. All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.matrixEqual(ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance)";
       description = "<b>matrixEqual</b><br><br>Checks if all elements of a matrix are different by less than or equal to a given tolerance.<br>The result will be put in the results table in column &quot;MatrixEqual&quot; as 1 if yes and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum2DBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum2DSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>maximum3DBox</b><br><br>Computes the local maximum of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum3DSliceBySliceSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>maximum3DSphere</b><br><br>Computes the local maximum of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximumBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>maximumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = max(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>maximumImages</b><br><br>Computes the maximum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = max(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>maximumOctagon</b><br><br>Applies a maximum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>maximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Max'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>maximumOfMaskedPixels</b><br><br>Determines the maximum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumXProjection</b><br><br>Determines the maximum projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumYProjection</b><br><br>Determines the maximum projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjectionBounded(ClearCLBuffer source, ClearCLBuffer destination_max, Integer min_z, Integer max_z)";
       description = "<b>maximumZProjectionBounded</b><br><br>Determines the maximum projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination_max, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.maximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumZProjection</b><br><br>Determines the maximum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>mean2DBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>mean2DSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>mean3DBox</b><br><br>Computes the local mean average of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.mean3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>mean3DSphere</b><br><br>Computes the local mean average of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanClosestSpotDistance(ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional)";
       description = "<b>meanClosestSpotDistance</b><br><br>Takes two binary images A and B with marked spots and determines for each spot in image A the closest spot in image B. Afterwards, it saves the average shortest distances from image A to image B as 'mean_closest_spot_distance_A_B' and from image B to image A as 'mean_closest_spot_distance_B_A' to the results table. The distance between B and A is only determined if the `bidirectional` checkbox is checked.<br><br>Parameters:<br>ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfAllPixels(ClearCLImageInterface source)";
       description = "<b>meanOfAllPixels</b><br><br>Determines the mean average of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Mean'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>meanOfMaskedPixels</b><br><br>Determines the mean intensity in an image, but only in pixels which have non-zero values in another binary mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanOfPixelsAboveThreshold(ClearCLBuffer source, Float threshold)";
       description = "<b>meanOfPixelsAboveThreshold</b><br><br>Determines the mean intensity in an image, but only in pixels which are above a given threshold.<br><br>Parameters:<br>ClearCLBuffer source, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>meanSliceBySliceSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanSquaredError(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>meanSquaredError</b><br><br>Determines the mean squared error (MSE) between two images. The MSE will be stored in a new row of ImageJs<br>Results table in the column 'MSE'.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjectionBounded(ClearCLBuffer source, ClearCLBuffer destination_mean, Integer min_z, Integer max_z)";
       description = "<b>meanZProjectionBounded</b><br><br>Determines the mean projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination_mean, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.meanZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanZProjection</b><br><br>Determines the mean average projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. The rectangle is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DBox</b><br><br>Computes the local median of a pixels cuboid neighborhood. The cuboid size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the cuboid must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSliceBySliceBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median3DSliceBySliceBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. This is done slice-by-slice in a 3D <br>image stack. The rectangle is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median3DSliceBySliceSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. This is done slice-by-slice in a 3D <br>image stack. The ellipses size is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.median3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DSphere</b><br><br>Computes the local median of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the sphere must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.medianZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>medianZProjection</b><br><br>Determines the median projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum2DBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum2DSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal neighborhood. The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>minimum3DBox</b><br><br>Computes the local minimum of a pixels cube neighborhood. The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum3DSliceBySliceSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>minimum3DSphere</b><br><br>Computes the local minimum of a pixels spherical neighborhood. The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimumBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination)";
       description = "<b>minimumDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the shortest distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>minimumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = min(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>minimumImages</b><br><br>Computes the minimum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = min(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>minimumOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>minimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Min'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>minimumOfMaskedPixels</b><br><br>Determines the minimum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjectionBounded(ClearCLBuffer source, ClearCLBuffer destination_min, Integer min_z, Integer max_z)";
       description = "<b>minimumZProjectionBounded</b><br><br>Determines the minimum projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination_min, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.minimumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>minimumZProjection</b><br><br>Determines the minimum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndCoordinate(ClearCLImageInterface source, ClearCLImageInterface destination, Integer dimension)";
       description = "<b>multiplyImageAndCoordinate</b><br><br>Multiplies all pixel intensities with the x, y or z coordinate, depending on specified dimension.</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer dimension";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>multiplyImageAndScalar</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s.<br><br><pre>f(x, s) = x * s</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyImages(ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination)";
       description = "<b>multiplyImages</b><br><br>Multiplies all pairs of pixel values x and y from two image X and Y.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyMatrix(ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination)";
       description = "<b>multiplyMatrix</b><br><br>Multiplies two matrices with each other.<br><br>Parameters:<br>ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.multiplyStackWithPlane(ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination)";
       description = "<b>multiplyStackWithPlane</b><br><br>Multiplies all pairs of pixel values x and y from an image stack X and a 2D image Y. x and y are at <br>the same spatial position within a plane.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.notEqualConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>notEqualConstant</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.notEqual(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLBuffer destination)";
       description = "<b>notEqual</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.openingBox(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations)";
       description = "<b>openingBox</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.openingDiamond(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations)";
       description = "<b>openingDiamond</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.organiseWindows(Integer startX, Integer startY, Integer tilesX, Integer tilesY, Integer tileWidth, Integer tileHeight)";
       description = "<b>organiseWindows</b><br><br>Organises windows on screen.<br><br>Parameters:<br>Integer startX, Integer startY, Integer tilesX, Integer tilesY, Integer tileWidth, Integer tileHeight";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetryTimelapse(ClearCLBuffer source, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift)";
       description = "<b>particleImageVelocimetryTimelapse</b><br><br>Run particle image velocimetry on a 2D+t timelapse.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.particleImageVelocimetry(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift)";
       description = "<b>particleImageVelocimetry</b><br><br>For every pixel in source image 1, determine the pixel with the most similar intensity in <br> the local neighborhood with a given radius in source image 2. Write the distance in <br>X and Y in the two corresponding destination images.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destinationDeltaX, ClearCLBuffer destinationDeltaY, ClearCLBuffer destinationDeltaZ, Integer maxDeltaX, Integer maxDeltaY, Integer maxDeltaZ, Boolean correctLocalShift";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste2D(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY)";
       description = "<b>paste2D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste3D(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY, Integer destinationZ)";
       description = "<b>paste3D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY, Integer destinationZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.paste(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY)";
       description = "<b>paste</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destinationX, Integer destinationY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pointIndexListToMesh(ClearCLBuffer pointlist, ClearCLBuffer indexList, ClearCLBuffer Mesh)";
       description = "<b>pointIndexListToMesh</b><br><br>Meshes all points in a given point list which are indiced in a corresponding index list. TODO: Explain better<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer indexList, ClearCLBuffer Mesh";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.powerImages(ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination)";
       description = "<b>powerImages</b><br><br>Calculates x to the power of y pixel wise of two images X and Y.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.power(ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent)";
       description = "<b>power</b><br><br>Computes all pixels value x to the power of a given exponent a.<br><br><pre>f(x, a) = x ^ a</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.preloadFromDisc(ClearCLBuffer destination, String filename, String nextFilename, String loaderId)";
       description = "<b>preloadFromDisc</b><br><br>This plugin takes two image filenames and loads them into RAM. The first image is returned immediately, the second image is loaded in the background and  will be returned when the plugin is called again.<br><br> It is assumed that all images have the same size. If this is not the case, call release(image) before  getting the second image.<br><br>Parameters:<br>ClearCLBuffer destination, String filename, String nextFilename, String loaderId";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.presign(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>presign</b><br><br>Determines the extrema of pixel values: f(x) = x / abs(x).<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullAsROI(ClearCLBuffer binary_input)";
       description = "<b>pullAsROI</b><br><br>Pulls a binary image from the GPU memory and puts it on the currently active ImageJ window.<br><br>Parameters:<br>ClearCLBuffer binary_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.pullLabelsToROIManager(ClearCLBuffer binary_input)";
       description = "<b>pullLabelsToROIManager</b><br><br>Pulls all labels in a label map as ROIs to the ROI manager.<br><br>Parameters:<br>ClearCLBuffer binary_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replaceIntensities(ClearCLImageInterface input, ClearCLImageInterface new_values_vector, ClearCLImageInterface destination)";
       description = "<b>replaceIntensities</b><br><br>Replaces integer intensities specified in a vector image. The vector image must be 3D with size (m, 1, 1) where m corresponds to the maximum intensity in the original image. Assuming the vector image contains values (0, 1, 0, 2) means: <br> * All pixels with value 0 (first entry in the vector image) get value 0<br> * All pixels with value 1 get value 1<br> * All pixels with value 2 get value 0<br> * All pixels with value 3 get value 2<br><br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface new_values_vector, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.replaceIntensity(ClearCLImageInterface input, ClearCLImageInterface destination, Float oldValue, Float newValue)";
       description = "<b>replaceIntensity</b><br><br>Replaces a specific intensity in an image with a given new value.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float oldValue, Float newValue";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ, Boolean linearInterpolation)";
       description = "<b>resample</b><br><br>Resamples an image with given size factors using an affine transform.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ, Boolean linearInterpolation";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceBottom(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceBottom</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceLeft</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceRight</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.resliceTop(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceTop</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate2D(ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter)";
       description = "<b>rotate2D</b><br><br>Rotates an image in plane. All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotate3D(ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter)";
       description = "<b>rotate3D</b><br><br>Rotates an image stack in 3D. All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateClockwise(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateClockwise</b><br><br>Rotates a given input image by 90 degrees clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateCounterClockwise(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateCounterClockwise</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateLeft</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.rotateRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateRight</b><br><br>Rotates a given input image by 90 degrees clockwise. For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.saveAsTIF(ClearCLBuffer input, String filename)";
       description = "<b>saveAsTIF</b><br><br>Pulls an image from the GPU memory and saves it as TIF to disc.<br><br>Parameters:<br>ClearCLBuffer input, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setColumn(ClearCLImageInterface source, Integer columnIndex, Float value)";
       description = "<b>setColumn</b><br><br>Sets all pixel values x of a given column in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Integer columnIndex, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setNonZeroPixelsToPixelIndex(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>setNonZeroPixelsToPixelIndex</b><br><br>Sets all pixels in an image which are not zero to the index of the pixel. This can be used for Connected Components Analysis.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setPlane(ClearCLImageInterface source, Integer rowIndex, Float value)";
       description = "<b>setPlane</b><br><br>Sets all pixel values x of a given plane in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Integer rowIndex, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampX(ClearCLImageInterface source)";
       description = "<b>setRampX</b><br><br>Sets all pixel values to their X coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampY(ClearCLImageInterface source)";
       description = "<b>setRampY</b><br><br>Sets all pixel values to their Y coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRampZ(ClearCLImageInterface source)";
       description = "<b>setRampZ</b><br><br>Sets all pixel values to their Z coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setRow(ClearCLImageInterface source, Integer rowIndex, Float value)";
       description = "<b>setRow</b><br><br>Sets all pixel values x of a given row in X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Integer rowIndex, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXequalsY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXequalsY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x == y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXgreaterThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXgreaterThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x > y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.setWhereXsmallerThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXsmallerThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x < y. Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br><pre>f(a) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.set(ClearCLImageInterface source, Float value)";
       description = "<b>set</b><br><br>Sets all pixel values x of a given image X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.shortestDistances(ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances)";
       description = "<b>shortestDistances</b><br><br>Determine the shortest distance from a distance matrix. This corresponds to the minimum in a matrix for each individial column.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGlasbeyOnGrey(ClearCLBuffer red, ClearCLBuffer labelling, String title)";
       description = "<b>showGlasbeyOnGrey</b><br><br>Visualises two 2D images as one RGB image. The first channel is shown in grey, the second with glasbey LUT.<br><br>Parameters:<br>ClearCLBuffer red, ClearCLBuffer labelling, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showGrey(ClearCLBuffer input, String title)";
       description = "<b>showGrey</b><br><br>Visualises a single 2D image.<br><br>Parameters:<br>ClearCLBuffer input, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.showRGB(ClearCLBuffer red, ClearCLBuffer green, ClearCLBuffer blue, String title)";
       description = "<b>showRGB</b><br><br>Visualises three 2D images as one RGB image<br><br>Parameters:<br>ClearCLBuffer red, ClearCLBuffer green, ClearCLBuffer blue, String title";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>smallerConstant</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerOrEqualConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>smallerOrEqualConstant</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smallerOrEqual(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smallerOrEqual</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.smaller(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smaller</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sobel(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>sobel</b><br><br>Convolve the image with the Sobel kernel.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sorensenDiceCoefficient(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>sorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent.<br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.spotsToPointList(ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>spotsToPointList</b><br><br>Transforms a spots image as resulting from maximum/minimum detection in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stackToTiles(ClearCLImageInterface source, ClearCLImageInterface destination, Integer tiles_x, Integer tiles_y)";
       description = "<b>stackToTiles</b><br><br>Stack to tiles.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer tiles_x, Integer tiles_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfAllPixels(ClearCLImageInterface source)";
       description = "<b>standardDeviationOfAllPixels</b><br><br>Determines the standard deviation of all pixels in an image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Standard_deviation'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>standardDeviationOfMaskedPixels</b><br><br>Determines the standard deviation of all pixels in an image which have non-zero value in a corresponding mask image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Masked_standard_deviation'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.standardDeviationZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>standardDeviationZProjection</b><br><br>Determines the standard deviation projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.statisticsOfLabelledPixels(ClearCLBuffer input, ClearCLBuffer labelmap)";
       description = "<b>statisticsOfLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity  of a labelled object in a label map and corresponding pixels in the original image.Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer labelmap";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.stopWatch(String text)";
       description = "<b>stopWatch</b><br><br>Measures time and outputs delay to last call.<br><br>Parameters:<br>String text";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground2D(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>subtractBackground2D</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground3D(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>subtractBackground3D</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractBackground(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY)";
       description = "<b>subtractBackground</b><br><br>Applies Gaussian blur to the input image and subtracts the result from the original image.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractImageFromScalar(ClearCLImageInterface input, ClearCLImageInterface destination, Float scalar)";
       description = "<b>subtractImageFromScalar</b><br><br>Subtracts one image X from a scalar s pixel wise.<br><br><pre>f(x, s) = s - x</pre><br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtractImages(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtractImages</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.subtract(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtract</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>sumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumPixels(ClearCLImageInterface source)";
       description = "<b>sumPixels</b><br><br>Determines the sum of all pixels in a given image. It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumYProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.sumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>sumZProjection</b><br><br>Determines the sum projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.tenengradFusion(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_substacks, Float sigmaX, Float sigmaY, Float sigmaZ, Float exponent)";
       description = "<b>tenengradFusion</b><br><br>Fuses #n# image stacks using Tenengrads algorithm.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_substacks, Float sigmaX, Float sigmaY, Float sigmaZ, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdDefault(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdDefault</b><br><br>The automatic thresholder utilizes the Default threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdHuang(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdHuang</b><br><br>The automatic thresholder utilizes the Huang threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdIJ_IsoData(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIJ_IsoData</b><br><br>The automatic thresholder utilizes the IJ_IsoData threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdIntermodes(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIntermodes</b><br><br>The automatic thresholder utilizes the Intermodes threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdIsoData(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIsoData</b><br><br>The automatic thresholder utilizes the IsoData threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdLi(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdLi</b><br><br>The automatic thresholder utilizes the Li threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMaxEntropy(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMaxEntropy</b><br><br>The automatic thresholder utilizes the MaxEntropy threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMean(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMean</b><br><br>The automatic thresholder utilizes the Mean threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMinError(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMinError</b><br><br>The automatic thresholder utilizes the MinError threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMinimum(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMinimum</b><br><br>The automatic thresholder utilizes the Minimum threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdMoments(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMoments</b><br><br>The automatic thresholder utilizes the Moments threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdOtsu(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdOtsu</b><br><br>The automatic thresholder utilizes the Otsu threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdPercentile(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdPercentile</b><br><br>The automatic thresholder utilizes the Percentile threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdRenyiEntropy(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdRenyiEntropy</b><br><br>The automatic thresholder utilizes the RenyiEntropy threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdShanbhag(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdShanbhag</b><br><br>The automatic thresholder utilizes the Shanbhag threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdTriangle(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdTriangle</b><br><br>The automatic thresholder utilizes the Triangle threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.thresholdYen(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdYen</b><br><br>The automatic thresholder utilizes the Yen threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.threshold(ClearCLBuffer source, ClearCLBuffer destination, Float threshold)";
       description = "<b>threshold</b><br><br>Computes a binary image with pixel values 0 and 1. All pixel values x of a given input image with <br>value larger or equal to a given threshold t will be set to 1.<br><br>f(x,t) = (1 if (x >= t); (0 otherwise))<br><br>This plugin is comparable to setting a raw threshold in ImageJ and using the 'Convert to Mask' menu.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>topHatBox</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatOctagonSliceBySlice(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>topHatOctagonSliceBySlice</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations - 2 makes the filter result very similar to minimum sphere.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>topHatOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations - 2 makes the filter result very similar to minimum sphere.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.topHatSphere(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>topHatSphere</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.touchMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination)";
       description = "<b>touchMatrixToMesh</b><br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a touch matrix of size n*n to draw lines from all points to points if the corresponding pixel in the touch matrix is 1.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.trainWekaModel(ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename)";
       description = "<b>trainWekaModel</b><br><br>Trains a Weka model using functionality of Fijis Trainable Weka Segmentation plugin.<br>It takes a 3D feature stack (e.g. first plane original image, second plane blurred, third plane edge image)and trains a Weka model. This model will be saved to disc.<br>The given groundTruth image is supposed to be a label map where pixels with value 1 represent class 1, pixels with value 2 represent class 2 and so on. Pixels with value 0 will be ignored for training.<br><br>Parameters:<br>ClearCLBuffer featureStack3D, ClearCLBuffer groundTruth2D, String saveModelFilename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate2D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY)";
       description = "<b>translate2D</b><br><br>Translate an image stack in X and Y.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translate3D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ)";
       description = "<b>translate3D</b><br><br>Translate an image stack in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translationRegistration(ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination)";
       description = "<b>translationRegistration</b><br><br>Measures center of mass of thresholded objects in the two input images and translates the second image so that it better fits to the first image.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.translationTimelapseRegistration(ClearCLBuffer input, ClearCLBuffer output)";
       description = "<b>translationTimelapseRegistration</b><br><br>Applies 2D translation registration to every pair of t, t+1 slices of a 2D+t image stack.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer output";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeXY(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXY</b><br><br>Transpose X and Y axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeXZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXZ</b><br><br>Transpose X and Z axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.transposeYZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeYZ</b><br><br>Transpose Y and Z axes of an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfAllPixels(ClearCLBuffer source)";
       description = "<b>varianceOfAllPixels</b><br><br>Determines the variance of all pixels in an image. The value will be stored in a new row of ImageJs<br>Results table in the column 'Variance'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.varianceOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>varianceOfMaskedPixels</b><br><br>Determines the variance in an image, but only in pixels which have non-zero values in another binary mask image. The result is put in the results table as new column named 'Masked_variance'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.watershed(ClearCLBuffer binary_source, ClearCLBuffer destination)";
       description = "<b>watershed</b><br><br>Apply a binary watershed to a binary image and introduces black pixels between objects.<br><br>Parameters:<br>ClearCLBuffer binary_source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeVTKLineListToDisc(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, String filename)";
       description = "<b>writeVTKLineListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and a corresponding touch matrix , sized (n+1)*(n+1), and exports them in VTK format.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeValuesToPositions(ClearCLBuffer positionsAndValues, ClearCLBuffer destination)";
       description = "<b>writeValuesToPositions</b><br><br>Takes an image with three/four rows (2D: height = 3; 3D: height = 4): x, y [, z] and v and target image. The value v will be written at position x/y[/z] in the target image.<br><br>Parameters:<br>ClearCLBuffer positionsAndValues, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clijx.writeXYZPointListToDisc(ClearCLBuffer pointlist, String filename)";
       description = "<b>writeXYZPointListToDisc</b><br><br>Takes a point list image representing n points (n*2 for 2D points, n*3 for 3D points) and exports them in XYZ format.<br><br>Parameters:<br>ClearCLBuffer pointlist, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
        return list;
    }
}
// 276 methods generated.
